#pragma config(Sensor, in1,    RightLF,        sensorLineFollower)
#pragma config(Sensor, in2,    CenterLF,       sensorLineFollower)
#pragma config(Sensor, in3,    LeftLF,         sensorLineFollower)
#pragma config(Sensor, in4,    LightSensor,    sensorReflection)
#pragma config(Sensor, in5,    ArmStatus,      sensorPotentiometer)
#pragma config(Sensor, dgtl4,  Bumper,         sensorTouch)
#pragma config(Sensor, dgtl5,  LimitSwitch,    sensorTouch)
#pragma config(Sensor, dgtl7,  Sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  IncoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, IncoderR,       sensorQuadEncoder)
#pragma config(Motor,  port2,           LeftMotor,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           Claw,          tmotorVex269, openLoop)
#pragma config(Motor,  port8,           Arm,           tmotorVex269, openLoop)
#pragma config(Motor,  port9,           RightMotor,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "Clawbot.h"
//#include <math.h>
								/*DISCRIPTION*/
/*
		This code is made to make the robot drive
		with out crashing into anything.
		It will use sonar to detect multuble distances
		to determen witch way it can go and for how long
*/
float whom;
float replaceIfNewMin(float a, float b){if(a>b){return b;} else{return a;}}
float number[19] = {300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300};

float Max()
{
	int max=0;
	int index=0;
	for(int i = 0; i>19; i++)//array.length
	{
		if(number[i]>max)
		{
			max = number[i];
			index = i;
		}
	}
	return index;
}

void rotate(int g) //+ er klukkuhringur og - er ofugdur klukkuhringur
{
	SensorValue[IncoderR] = 0;
  SensorValue[IncoderL] = 0;
	if(g>0)
	{
		while( SensorValue[IncoderL]<g*3.1731)//360=U
		{
				motor[RightMotor] = -60;
				motor[LeftMotor]  = +60;
		}
	}
	else
	{
		while(SensorValue[IncoderL]>g*3.1731)
		{
				motor[RightMotor] = +60;
				motor[LeftMotor]  = -60;
		}
	}
	motor[RightMotor] = 0;
	motor[LeftMotor]  = 0;
}

void navigate()
{
	int distance[29];
	rotate(-90);
	wait1Msec(500);
	//scans//get the values
	for(int i = 0; i<28;i++)
	{
		distance[i] =	SensorValue(Sonar);
	wait1Msec(500);
		rotate(7);
	}
	wait1Msec(500);
		distance[28] =	SensorValue(Sonar);//the last one(no need to rotate after this one)

	float c;
	float x;
	float y;
	float xshift;
	float yshift;
	for(int i = 0; i<19;i++)//foreach possible course
	{
		xshift = (cosDegrees(W-10+i*10)-cosDegrees(W))*SENSOR_R;
		yshift = (sinDegrees(W-10+i*10)-sinDegrees(W))*SENSOR_R;
		c = distance[i];
	  x = c*cosDegrees(10)+xshift;
	  y = c*sinDegrees(10)+yshift;
		//check the left
		if(WIDTH_L>x&&c!=-1)
		{
			number[i]=y;
		}
		//checkFront
		if(distance[i+1]!=-1)
		{
			number[i]=replaceIfNewMin(distance[i+1],number[i]);
		}
		for(int k = 0; k<8;k++)
		{
			xshift=(cosDegrees(W-10+(k+i+2)*10)-cosDegrees(W))*SENSOR_R;
			yshift=(sinDegrees(W-10+(k+i+2)*10)-sinDegrees(W))*SENSOR_R;
			c=distance[i+2+k];
	  	x = c*cosDegrees(10+10*k)+xshift;
	  	y = c*sinDegrees(10+10*k)+yshift;

			if(WIDTH_R>x&&c!=-1)
			{
				number[i]=replaceIfNewMin(y,number[i]);
			}
		}
	}
	rotate(-90-Max()*10);
}

void drive(float distance)
{
	SensorValue[IncoderL]=0;
	SensorValue[IncoderR]=0;
	while((/*SensorValue(Sonar) > 40 ||*/ SensorValue(Sonar)<0)&&(distance/U > SensorValue[IncoderR]/360 && distance/U > SensorValue[IncoderL]/360))//drives X meter or untill he finds a blockcade
	{
		if(abs(SensorValue[IncoderR]) == abs(SensorValue[IncoderL]))
		{
			motor[RightMotor] = 80;
			motor[LeftMotor]  = 80;
		}
		else if(abs(SensorValue[IncoderR]) < abs(SensorValue[IncoderL]))
		{
			motor[RightMotor] = 90;
			motor[LeftMotor]  = 70;
		}
		else
		{
			motor[RightMotor] = 70;
			motor[LeftMotor]  = 90;
		}
	}
}

task myMain()
{
	while(true)
	{
		navigate();
		whom = number[Max()];
		drive(number[Max()]);
	}
}
task main()
{
	StartTask(myMain);//run the program

	while(vexRT[Btn8D]!=true&&Bumper!=true){}//don't stop untill we say so

	StopAllTasks();//stop everything!
}
